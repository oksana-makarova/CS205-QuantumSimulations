% ED for block diagonal matrices; XXZ Hamiltonian 
% Oksana, 04/30/2021

% if you want to test the function: ED_evolve_block_diag(NN, M, XXZCoeff, init_state)
% and uncomment rng(0) and Jmat
function ED_evolve_block_diag_gpu_parfeval(NN, M, XXZCoeff, Jmat, init_state)
%NN = 7; % number of spins
%M number of time points of interest
%XXZCoeff - parameter to tune the Hamiltonian 
%Jmat - coupling coefficients (Jij)
%(Z state should never decay if disorder is 0; X and Y don't decay if XXZCoeff = 0)
sx = 0.5*[0, 1; 1 0];
sy = 0.5*[0 -1i; 1i 0];
sz = 0.5*[1 0; 0 -1];

v0 = [1; 0];
v1 = [0; 1];

%% parameters
%Delta = 0.1; %variance of disorder 
rng(0) %setting seed # to zero to getthe same random matrix each time for testing
Jmat = randi([-5,5],NN);
%M = 1000;
%h3 = 3;
%t_pi = pi/(2*h3);
t_max = 100000;
t = linspace(0, t_max, M);

%initial wavefunction
if init_state == "X"
    theta = pi/2; phi = 0;
elseif init_state == "Y"
    theta = pi/2; phi = pi/2;
elseif init_state == "Z"
    theta = 0; phi = 0;
else
    error("please enter X, Y, or Z initial state or change the code")
end

psi0 = cos(theta/2)*v0 + sin(theta/2)*exp(1i*phi)*v1;
psi_i = psi0;

%convert to GPU
psi_i = gpuArray(psi_i);
psi0 = gpuArray(psi0);

for i = 2:NN
    psi_i = kron(psi0, psi_i);
end

%% Step 1: big Hamiltonian construction
%Ham_big = sparse(2^NN, 2^NN);
Ham_big = zeros(2^NN, 2^NN);

%convert to GPU arrays
Ham_big = gpuArray(Ham_big);

%% define operators for big Hamiltonian:
% we should end up with something like I*I*...*sx*...*I
%for each spin, where sx is the location in the chain of that particular spin
for i = 1:NN
    if i == 1 %first spin
        oper_at(i).sx = kron(sx, speye(2^(NN-1)));
        oper_at(i).sy = kron(sy, speye(2^(NN-1)));
        oper_at(i).sz = kron(sz, speye(2^(NN-1)));
    else %any further spin
        oper_at(i).sx = speye(2, 2);
        oper_at(i).sy = speye(2, 2);
        oper_at(i).sz = speye(2, 2);
        for j = 2:NN %find it's location in the chain to put sx there
            if i == j 
                oper_at(i).sx = kron(oper_at(i).sx, sx);
                oper_at(i).sy = kron(oper_at(i).sy, sy);
                oper_at(i).sz = kron(oper_at(i).sz, sz);
            else
                oper_at(i).sx = kron(oper_at(i).sx, speye(2, 2));
                oper_at(i).sy = kron(oper_at(i).sy, speye(2, 2));
                oper_at(i).sz = kron(oper_at(i).sz, speye(2, 2));
            end
        end
    end
end

%% non-interacting part: disorder
%{
%added Normally distributed disorder of variance Delta
for i = 1:NN
%     Ham_big = Ham_big + (-1)^(i) * h1 * oper_at(i).sx ...
%               + (-1)^(i+1) * h1 * oper_at(i).sy ...
%               + h0 * oper_at(i).sz;
    h_z = Delta * randn;      
    %h_z = 1;
    Ham_big = Ham_big + h_z * oper_at(i).sz;
end
%}

%% interacting part
for i = 1:(NN - 1) % kron(A, B)*kron(C, D) = kron((A*C), (B*D))
    for j = (i+1):NN
        Jij = Jmat(i, j); %generated by get_couplings.m, based on the distance between the spins
        %want: H = 1/6 * Jij(SS + XXZCoeff(SxSx + SySy - 2 SzSz)); note 1/6 that came from another code convention
        Ham_big = Ham_big + 1/6 * Jij * ((oper_at(i).sx * oper_at(j).sx ...
                         + oper_at(i).sy * oper_at(j).sy...
                         + oper_at(i).sz * oper_at(j).sz)... % SS part
                         + XXZCoeff * ... 
                         (oper_at(i).sx * oper_at(j).sx ...
                         + oper_at(i).sy * oper_at(j).sy...   
                         - 2 * oper_at(i).sz * oper_at(j).sz)); % tuned part
    end
end
%}


%% Evolution of big Hamiltonin without blocking
% uncomment if you want to compare psiEig_f_times and psi_f_times_blk_tot
%{
% change of basis
[eigvecs_big, eigvals_big] = eig(full(Ham_big), 'vector');
psiEig_i = eigvecs_big' * psi_i; %coordinate transformation
psiEig_i_times = repmat(psiEig_i, 1, M);
eigs_ts = eigvals_big * t;
evolver = exp(-1i*eigs_ts);
% evolving the state
psiEig_f_times = psiEig_i_times .* evolver;
%convert the state back to original basis and normalize
psi_f_times = eigvecs_big * psiEig_f_times; 
norm_psi = vecnorm(psi_f_times);
psi_f_times = bsxfun(@rdivide, psi_f_times, norm_psi);
%}


%% Divide big Hamiltonian into blocks with same # of excitations and evolve them separately, combine at the end

% Step 1: write out basis states and order them according to number of
% excitations

all_states = de2bi(0:2^NN-1, 'left-msb'); %our states are binary numbers with 0/1 <->spin up/down
exc_in_a_row = sum(all_states, 2); 
[~, blocking_indx] = sort(exc_in_a_row); %used to select correct rows/columns out of big Ham

blk_sizes = 0:NN;
blk_sizes = arrayfun(@(z) nchoosek(NN, z), blk_sizes); %sizes of each of the blocks, used for indexing

% Step 2: form blocks, find their eigenvalues and eigenvectors, evolve
% corresponding pieces of the wavefunction
parpool('local',gpuDeviceCount("available"));

psi_f_times_blk_tot = zeros(2^NN, M); %initialize evolved wavefunction
% blk_timings = zeros(NN+1,1);
% par_timings = zeros(NN+1,1);

for blk_num = 1:(NN+1)
   
    first_indx = sum(blk_sizes(1:(blk_num-1))); %first state index for this block
    selected_indx = blocking_indx((first_indx + 1):(first_indx + blk_sizes(blk_num)));
    
    %pick out elements for blocks from H based on blocking index
    Ham_blk = Ham_big(selected_indx, selected_indx);
    psi_blk = psi_i(selected_indx);
    
%     eig_vals_split((first_indx + 1):(first_indx+blk_sizes(blk_num))) = eig(Ham_blk);
%     tic;
    [eigvecs_blk, eigvals_blk] = eig(full(Ham_blk));
%     blk_timings(blk_num) = toc;
    
    %evolution (gpu + parfeval)
%     tic;
    fevalMult = @(A,B)A*B;
    f = parfeval(fevalMult,1,eigvecs_blk',psi_blk);
    psiEig_i_blk = fetchOutputs(f); %coordinate transformation
    clear f;
    psiEig_i_times_blk = repmat(psiEig_i_blk, 1, M);
    f = parfeval(fevalMult,1,diag(eigvals_blk),t);
    eigs_ts_blk =  fetchOutputs(f);
    clear f;
    evolver_blk = exp(-1i * eigs_ts_blk);
    
    %% evolving the state (gpu + parfeval)
    psiEig_f_times_blk = psiEig_i_times_blk .* evolver_blk;
    
    %convert the state back to original basis and normalize
    f = parfeval(fevalMult,1,eigvecs_blk,psiEig_f_times_blk);
    psi_f_times_blk = fetchOutputs(f);
    clear f;
    
    psi_f_times_blk_tot(selected_indx, :) = psi_f_times_blk;
%     par_timings(blk_num) = toc;
end

% fprintf('Timings for Oksana matrix blocking eig [s]: %4.4f\n',sum(blk_timings));
% fprintf('Timings for // matrix mults [s]: %4.4f\n',sum(par_timings));

%normalization
norm_psi_blk = vecnorm(psi_f_times_blk_tot);
psi_f_times_blk_tot = bsxfun(@rdivide, psi_f_times_blk_tot, norm_psi_blk);
    

%% measure Z polarization in the most bruteforce way
SN = sparse(2^NN, 2^NN);
%SN = zeros(2^NN, 2^NN);

%pick measurement basis
if (theta == pi/2 && phi == 0) %along X for X initial state
    for i = 1:NN
        SN = SN + oper_at(i).sx;
    end
elseif (theta == pi/2 && phi == pi/2) %along Y for Y initial state
    for i = 1:NN
        SN = SN + oper_at(i).sy;
    end
else %along Z otherwise
    for i = 1:NN
        SN = SN + oper_at(i).sz;
    end
end
%<psi|Sz|psi>, normalize by 2/(the number of spins) so that it
%stays between -1 and 1
%initial_polarization = real(psi_f_times(:, 1)' * SN * psi_f_times(:, 1))
%final_polarization = real(psi_f_times(:, M)' * SN * psi_f_times(:, M))
polarization = zeros(1, M);
for i = 1:M
    polarization(i) = real(psi_f_times_blk_tot(:, i)' * SN * psi_f_times_blk_tot(:, i)) *2/NN;
end

f1 = figure; close(f1);
plot(t, polarization, 'LineWidth',2.0);
xlabel("time")
ylabel("normalized polarization")
ylim([-1.1 1.1])
%% trace out first qubit using SVD
% psi_mat = transpose(psi_f_times(:, M));
% psi_mat = [psi_mat(1:length(psi_mat)/2); psi_mat((length(psi_mat)/2+1):end)];
% [U,S,V] = svd(psi_mat);
% Rho_1_svd = S(1, 1)^2*(U*v0)*(U*v0)'+S(2, 2)^2*(U*v1)*(U*v1)'


%% density matrix
% Rho_tot = zeros(size(psi_f_times_blk_tot, 1));
% for i = 1:M
%     Rho_i = psi_f_times_blk_tot(:, i)*psi_f_times_blk_tot(:, i)';
%     Rho_tot = Rho_tot + Rho_i; 
% end
% Rho_i = psi_i*psi_i';
% Rho_avg = Rho_tot / M;
% Rho_f = psi_f_times_blk_tot(:, M)*psi_f_times_blk_tot(:, M)';

%% Sanity check: both taces have to always be one
%Rho_i = psi_i*psi_i';
%Rho_f = psi_f_times_blk_tot(:, M)*psi_f_times_blk_tot(:, M)';
% Tr_init = trace(Rho_i)
% Tr_final = trace(Rho_f)

%% Close pool
delete(gcp);

end
